#!/usr/bin/ruby

########################
###   Batch Rename   ###
########################
$version = "1.6.24"

# Written by Matt Jordan -
# Insipred by Dmitry Nedospasov

require 'rubygems'
require 'ftools'
require 'Getopt/Declare'
require 'ostruct'

$op = OpenStruct.new

args = Getopt::Declare.new(<<'EOF')

-i                  invert [requires: (-u || --uppercase) || (-l || --lowercase)] [excludes: -a --all]
{ $op.invert = 1 }
--invert            [ditto]

-c                  ignore Pattern Case
{ $op.ignore_case = 1 }
--case              [ditto]

--debug              DEBUG
{ $op.debug = 1 }

-u                  upcase [excludes: -l --lowercase]
{ $op.upcase = 1 }
--uppercase         [ditto]

-l                  lowercase [excludes: -u --uppercase]
{ $op.downcase = 1}
--lowercase         [ditto]

-a                  all
{ $op.all = 1}
--all               [ditto]

-v                  Version
{ $op.version = 1 }
--version           [ditto]

-V                  Verbose [excludes: -q --quiet]
{ $op.verbose = 1 }
--verbose           [ditto]

-q                  Quiet [excludes: -V --verbose]
{ $op.quiet = 1 }
--quiet             [ditto]

-h                  Help
{ $op.help = 1 }
--help              [ditto]

-t <value:i>        Trim
{ $op.trim = value ; $op.trimt = 1}
--trim              [ditto]

-d                  Directories
{ $op.dirs = 1 }
--dirs              [ditto]

-D                  Only Directories
{ $op.only_dirs = 1 }
--only_dirs         [ditto]

-A                  Append
{ $op.append = 1 }
--append            [ditto]

-P                  Prepend
{ $op.prepend = 1 }
--prepend            [ditto]

EOF

class Filelist

  def initialize()
  debug("initializing Filelist")

    @dir = `pwd`.chomp + "/"
    @orig_list_array = Array.new
    @filecount = 0

    #check for existance of dir - abort if not
    begin
      @dir == nil ? a = 1/0 : {}
    rescue
      puts  'Script failed. Could not automagically retrive current working directory.'
      exit
    end

    #create an array of all the filenames - skip directories
    Dir.foreach(@dir) do |f|

      next if f == '.' or f == '..'
      @filecount += 1
      #switch for directory options
      case 1
      when $op.only_dirs
        next if ! File.directory?(f)
      when   $op.dirs
      else
       next if File.directory?(f)
      end

      @orig_list_array << f
    end #Dir

    #Check to see if list_array is empty. - if so abort.
    begin
      @orig_list_array.empty? ? a = 1/0 : {} #raise exception to abort program
    rescue
      puts "There are no files to rename. Batch is aborting.\n"
      a = 1/0 #raise exception to abort program
    ensure
    end

    @list_array = @orig_list_array
    @searchcount = @orig_list_array.length

  end #init

  def pattern
  debug("pattern")
    
    # Error check - abort if no pattern!
    begin
      $pattern == nil ? a = 1/0 : {}
    rescue
      puts "You must supply a PATTERN or use the -a/--all option."
      print_usage{exit}
    ensure
    end
    
    positive_array = Array.new
    negative_array = Array.new

    #search for matching patterns - divy the results into two arrays
    # Also deal with the ignore case switch here.
    if $op.ignore_case == 1
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.downcase.include?($pattern.downcase)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each

    else
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.include?($pattern)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each
    end #if $op.ignore_case


    #Deal with inversion pattern here:
    if $op.invert == 1
      @list_array = negative_array
    else
      @list_array = positive_array
    end

  end #pattern


  def create_hash
    debug("create_hash")
      
    #create hash from array
    @list_hash = Hash[ *@list_array.collect { |v| [ v, v ] }.flatten ]
  end


  def upcase
    debug("upcase")

    create_hash
    
    up_hash = Hash.new

    @list_hash.each_key do |key|
      up_hash[key]=key.to_s.upcase
    end

    print !$op.quiet ? "Changing file names to Uppercase.\n" : {}

    @list_hash.merge!(up_hash)
  end #upcase


  def downcase
  debug("downcase")

    create_hash

    down_hash = Hash.new

    @list_hash.each_key do |key|
      down_hash[key]=key.to_s.downcase
    end

    print !$op.quiet ? "Changing file names to Lowercase.\n" : {}

    @list_hash.merge!(down_hash)
  end #downcase


  def trim
  debug("trim")

    create_hash

    sub_hash = Hash.new

    if $op.trim == 0
      then
      puts "Trimming 0 characters does you no good!"
      print_usage{exit}
      
    #negative trim number
    elsif $op.trim <= 0
      @list_hash.each_key do |key|

          #make sure trim isn't too big
          if (-1 * $op.trim) < key.length
          sub_hash[key] = key.slice(($op.trim * -1)..key.length)

          end
        end        

    #positive trim number
    elsif $op.trim >= 0
      @list_hash.each_key do |key|
    
        #make sure trim isn't too big
        if $op.trim < key.length
          sub_hash[key] = key.slice(0..(key.length - $op.trim - 1))

        end #if
      end #each
    end #if

    @list_hash = sub_hash
  
  end #trim


  def substitute
  debug("substitute")
  
    create_hash
    
    #error checking for errant options
    # cannot use -all option with sub.
    begin
      $op.all ? a = 1/0 : {}
    rescue
      puts  'Ignoring the all option while performing a PATTERN substitution.'
    ensure
    end

    #error checking for errant options
    # cannot use -invert option with sub.
    begin
      $op.invert ? a = 1/0 : {}
    rescue
      puts  'Script aborted, you cannot apply a PATTERN substitution with the invert option.'
      exit #raise exception to abort program
    ensure
    end

    #populate @list_hash values with gsubbed keys
    sub_hash = Hash.new

    @list_hash.each_key do |key,value|
      if $op.ignore_case == 1
        sub_hash[key] = key.gsub(/#{$pattern}/i,$replacement)
      else
        sub_hash[key] = key.gsub($pattern,$replacement)
      end #if
    end #each.key

    @list_hash.merge!(sub_hash)

  end #substitute


  def xx_pend
  debug("xx_pend")

    create_hash

    #populate @list_hash values with gsubbed keys
    sub_hash = Hash.new

    @list_hash.each_key do |key,value|
      $op.append == 1 ? sub_hash[key] = key + $replacement : {}
      $op.prepend == 1 ? sub_hash[key] = $replacement + key : {}
    end #each.key

    @list_hash.merge!(sub_hash)

  end #xx_pend


  def rename_action
  debug("rename_action")

    @renamecount = 0

    #get rid of empty values in the hash.
    @list_hash.delete_if { |key, value| value == '' }
    @list_hash.each_pair do |key, value|

      #check for duplicate key/value, & files - prevent clobbering
      if key != value and not @orig_list_array.include?(value)
        @renamecount += 1

        File.rename(key, value)

        #announce renames
        verbose("#{key}  >>>   #{value}\n")
        
      else

        #announce clobbering
        verbose("#{key} will clobber #{value}; rename aborted.\n")

      end #anti-clobber if
    end #@list_hash.each

  print $op.quiet != 1 ? "#{@renamecount} renames | #{@searchcount} matches | #{@filecount} objects.\n" : {}
  
  end #rename_action
end #filelist


def print_usage
  debug("print_usage")

  puts  'Usage: batch.rename [-acDilqtuvV] [PATTERN] [REPLACEMENT]'
  block_given? ? yield : {}
end


def print_version
  debug("print_version")

  puts "Batch Rename v. #{$version}\n"
  block_given? ? yield : {}
end


def debug(i)
  $op.debug == 1 ? puts("==== #{i} ====") : {}
end


def verbose(i)
  $op.verbose == 1 ? puts(i) : {}
end

def print_help
  debug("printing help")
  
  print_version
  print_usage
  puts "\n"
  puts "Batch Rename is a substitution based batch file renamer with additional modes & options."
  puts "Typically REPLACEMENT replaces the PATTERN for all filenames in the local directory.  To delete"
  puts "the PATTERN from the file names, do not enter a REPLACEMENT.  When the editing mode is changed,"
  puts "PATTERN acts as a search filter.  All whitespaces inside the PATTERN or REPLACEMENT should be"
  puts "escaped with a backslash (\\), or the whole phrase should be in quotation marks (\"\" or \'\').\n\n"
  puts "-t # --trim #      Trim Mode: (+#) characters from end or (-#) characters from beginning."
  puts "-u --upperercase   Uppercase mode. Change filenames to uppercase. Requires PATTERN or the -all option."
  puts "-l --lowercase     Lowercase mode. Change filenames to lowercase. Requires PATTERN or the -all option."
  puts "-A --append        Append mode.  Requires PATTERN or the -all option."
  puts "-P --prepend       Prepend mode.  Requires PATTERN or the -all option.\n "
  puts "-d --dirs          Include directories in PATTERN search.  Off by default."
  puts "-D --only-dirs     Exclude all except directories in PATTERN search."
  puts "-a --all           Disregard PATTERN, include all files in edit."
  puts "-i --invert        Invert results from PATTERN.  Not compatible with all options."
  puts "-c --case          Ignore case of PATTERN.\n "
  puts "   --debug         Print debug dialogues."
  puts "-v --version       Print program version."
  puts "-V --verbose       Verbose output."
  puts "-q --quiet         Quiet output."
  puts "-h --help          Print this help."

#  puts "--index            planned, not implimented"
#  puts "-X                 planned, only affect extensions"
#  puts "-x                 planned, preserve extensions"
#  puts "--propercase       planned"
#  puts "                   planned, add extension to files lacking them"
#  puts "-A --append        planned, append to filename"
#  puts "-P --prepend       planned, prepend to filename"
#  puts "-s --step          planned, step confirmation of each file rename"
#  puts "-c --confirmation  planned, confirm results before proceeding with rename"
#  puts "-t --test          planned, dry run of rename, with printed results"
#  puts "-r --recursive     planned, recursive rename? - maybe a baaaaad idea"
#  puts "-f --force         planned, force overwriting of destination files"
  puts ""
  block_given? ? yield : {}
end


def main()
  debug("DEBUG MODE ON")
  debug("main()")

if $op.prepend == 1 or $op.append == 1
  then

  if ARGV[1] && ARGV[0] != nil
      $pattern = ARGV[0]
      $replacement = ARGV[1]
    elsif ARGV[0] != nil
      $replacement = ARGV[0]
    end

  else
  $pattern = ARGV[0]
  $replacement = ARGV[1]
  $replacement ||= ''
end

debug("PATTERN: #{$pattern}")
debug("REPLACEMENT: #{$replacement}")

  case 1
  when $op.help
    print_help{exit}
  when $op.version
    print_version{exit}
  end

  bob = Filelist.new


  if $op.all != 1
    bob.pattern
  end

  case 1
  when $op.upcase
    bob.upcase
  when $op.downcase
    bob.downcase
  when $op.trimt
    bob.trim
  when $op.append
    bob.xx_pend
  when $op.prepend
    bob.xx_pend
  else
    $pattern == nil ? print_usage{exit} : bob.substitute
  end

  bob.rename_action

end #main


#begin
main()
#rescue
#end
