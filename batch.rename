#!/usr/bin/ruby

########################
###   Batch Rename   ###
########################
@version = "1.3.18"

# Based on script by Dmitry Nedospasov
# Updated & expanded by Matt Jordan -

# --- TODO ---

### Error Checking
# => check if target filname already exists
  # error on name collisions or continue and report after?
# => check permissions
  # abort right away if permissions are lacking
# => is file locked?
# => error catching

# => lock files during name changes?  nesessary?





### Selecting Files (PATTERN stuff) ###

# => Regex support?
# => Wildcard & globbing support!

### All option; -a --all
# => disregard PATTERN matching; do these things to all files.

### Inclusion Mode; -I --include
# => perform operations on the whole filename found by a PATTERN match
# => implied with propercase or sentencecase

### Inversion Mode?; -i --invert
# => Invert results from PATTERN match
# => instead of: "affect only matches"; acts like: "affect only not matches". 

### Ignore PATTERN case; -

### File Extension Support? (.pdf, .xls, ...); -x --extensions
# => Add supplied extensions onto files that do not have extensions
# => Change all extensions
# => Delete all extensions
# => Delete extensions that match PATTERN
# => Preserve extensions that match PATTERN
# => PATTERN + Gsub! only extensions <- not needed with wildcards?

  # => x - restrict changes to only extensions
  # => -ix - exclude extensions from changes; preserve extensions


### Meta ###

### Version option; -v --version
# => print program version

### Help; -h --help
# => display rudimentary help


### Reporting and data ###

### Confirmation; default behavior
# => report proposed changes and request confirmation of intent
# => require a full yes/no, not y/n?

### Step confirmation; -S --step
# => Steps through each file and requests y/n confirmation

### Force; -f --force
# => operate renames without user confirmation

### Print; -p --print
# => print a formated list of renamed files after execution
# => number of files changed
# => errors encountered
# => how does this work with the confirmation mode?

### Test; -t --test
# => dry run w/ print
# => does not change files

### Verbose Mode; -V --verbose
# => show renames and progress in situ




### Actions ###

### Default Mode; Gsub based
# => batch.rename PATTERN replacementtext

### Uppercase; -U --uppercase
### Lowercase; -l --lowercase
### Sentencecase; -s --sentence

### Append; -A --append
# => Append ___ to files
# => Append with index?
# => auto number based on date/time
# => auto number from range

### Prepend; -P --prepend
# => Prepend ___ to files
# => prepend with index?
# => auto number based on date/time
# => auto number from range

### Trim;
# => trim first x
# => trim last x


### Recursive Rename; -r --recurse
# => default to a confirmation to prevent chaos?


### Related features and questions: ###

### Directory Handling?
# => -D --directories (rename (only or additionally) directories as well?)
# => how does the current script behave with directories?

### Target renames into another directory?
# => batch.rename --target ~/bob/albums PATTERN replacementtext

# make compatible with windows?


###############
### Process ###
###############

# => Parse Args
# => Get files -> get list of files
# => Perform Actions

#Object -> start with a hash of all file names in directory


###############################
### Rename Engine Structure ###
###############################


### Mode Structure
# => Multiple modes? Original PATTERN + GSUB not the heart of the script?
# => Or make the Original PATTERN + GSUB mode heliocentric, with all other
  # functionality requiring options?

# => modular
# => enable features & engine differences with flags?
# => write seperate cases depending on options?
  # => not very flexible, harder to use seperate options together
# => seperate cases and modifier options (with flags?)


require 'rubygems'
require 'ftools'

def main(arguments, stdin)

  @dir = `pwd`.chomp + "/"

  oldExt = arguments[0]
  newExt = arguments[1]
  @searchcount = 0
  @renamecount = 0


  if ARGV.length >= 3
    puts 'Too many arguments'
    puts 'Usage: batch.rename PATTERN [REPLACEMENT PATTERN]'
  elsif oldExt == nil
    puts 'Usage: batch.rename PATTERN [REPLACEMENT PATTERN]'
  elsif  @dir == nil
    puts  'Script failed. Could not automagically retrive current working directory.'
  else
    if newExt == nil
      puts "deleting #{oldExt} from file names..."
    else
      puts "renaming #{oldExt} to #{newExt}"
    end
    convertFromTo(@dir,oldExt,newExt)
    print "#{@searchcount} files were searched.\n"
    print "#{@renamecount} files were successfully renamed.\n"
  end
end


def convertFromTo(dir, oldExt, newExt)


  Dir.foreach(dir) do |f|

    #skip file if it is . or .. or directory
    next if f == '.' or f == '..'
    next if File.directory?(f)
    @searchcount += 1

    # fullPath = fullPath.gsub(' ','\ ')

# => if file is a directory recurse into it
#    if File.directory?(fullPath)
#      convertFromTo(fullPath, oldExt, newExt)
#    else

   if newExt == nil
     newName = f.gsub(oldExt,'')
   else
     newName = f.gsub(oldExt,newExt)
   end

    if f != newName
    @renamecount += 1
      
# =>  list file option
#      puts f + '  ->  ' + newName
      File.rename(f,newName)
    end
  end #do
end #def

main(ARGV, STDIN)