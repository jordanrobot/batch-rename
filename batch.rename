#!/usr/bin/ruby

########################
###   Batch Rename   ###
########################
$version = "1.5.27"

# Based on script by Dmitry Nedospasov
# Updated & expanded by Matt Jordan -


require 'rubygems'
require 'ftools'
require 'Getopt/Declare'
require 'ostruct'

    $op = OpenStruct.new


args = Getopt::Declare.new(<<'EOF')

-i                  invert [requires: (-u || --uppercase) || (-l || --lowercase)] [excludes: -a --all]
{ $op.invert = 1 }
--invert            [ditto]

-c                  ignore Pattern Case
{ $op.ignore_case = 1 }
--case              [ditto]

-D                  DEBUG
{ $op.debug = 1 }
--debug             [ditto]

-u                  upcase [excludes: -l --lowercase]
{ $op.upcase = 1 }
--uppercase         [ditto]

-l                  lowercase [excludes: -u --uppercase]
{ $op.downcase = 1}
--lowercase         [ditto]

-a                  all
{ $op.all = 1}
--all               [ditto]

-v                  Version
{ $op.version = 1 }
--version           [ditto]

-V                  Verbose [excludes: -q --quiet]
{ $op.verbose = 1 }
--verbose           [ditto]

-q                  Quiet [excludes: -V --verbose]
{ $op.quiet = 1 }
--quiet             [ditto]

-h                  Help
{ $op.help = 1 }
--help              [ditto]

-t <value:i>        Trim
{ $op.trim = value }
--trim              [ditto]

EOF

puts $op.debug ? "==== DEBUG MODE ON ====\n" : ""

class Filelist

  def initialize()

    @dir = `pwd`.chomp + "/"
    @orig_list_array = Array.new

    puts $op.debug ? "==== initialization() ====\n" : ""


    #check for existance of dir - abort if not
    begin
      @dir == nil ? a = 1/0 : nil
    rescue
      puts  'Script failed. Could not automagically retrive current working directory.'
      exit
    ensure
    end

    #create an array of all the filenames - skip directories
    Dir.foreach(@dir) do |f|
      next if f == '.' or f == '..'
      next if File.directory?(f)
      @orig_list_array << f
    end #Dir
    @list_array = @orig_list_array

    #Check to see if list_array is empty. - if so abort.
    begin
      if @orig_list_array.empty?
        a = 1/0 #raise exception to abort program
      end
    rescue
      puts "There are no files to rename. Batch is aborting.\n"
      a = 1/0 #raise exception to abort program
    ensure
    end

    @searchcount = @orig_list_array.length

  end #init

  def pattern()

    puts $op.debug ? "==== pattern() ====\n" : ""
    
    # Error check - abort if no pattern!
    begin
      if $pattern == nil
        a = 1/0 #raise exception to abort program
      end
    rescue
      print_usage
      exit #raise exception to abort program
    ensure
    end
    
    positive_array = Array.new
    negative_array = Array.new

    #search for matching patterns - divy the results into two arrays
    # Also deal with the ignore case switch here.
    if $op.ignore_case == 1
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.downcase.include?($pattern.downcase)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each

    else
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.include?($pattern)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each
    end #if $op.ignore_case


    #Deal with inversion pattern here:
    if $op.invert == 1
      @list_array = negative_array
    else
      @list_array = positive_array
    end

  end #pattern


  def create_hash()
    p $op.debug ? "==== create_hash() ====\n" : "\b"

    #create hash from array
    @list_hash = Hash[ *@list_array.collect { |v| [ v, v ] }.flatten ]
  end


  def upcase()
    p $op.debug ? "==== upcase() ====\n" : ""

    create_hash()
    
    up_hash = Hash.new

    @list_hash.each_key do |key|
      up_hash[key]=key.to_s.upcase
    end

    print !$op.quiet ? "Changing file names to Uppercase.\n" : nil

    @list_hash.merge!(up_hash)
  end #upcase


  def downcase()
    p $op.debug ? "==== downcase() ====\n" : ""

    create_hash()

    down_hash = Hash.new

    @list_hash.each_key do |key|
      down_hash[key]=key.to_s.downcase
    end

    print !$op.quiet ? "Changing file names to Lowercase.\n" : nil

    @list_hash.merge!(down_hash)
  end #downcase


  def trim()
  
    p $op.debug ? "==== trim() ====\n" : ""

    create_hash()

    sub_hash = Hash.new

    if $op.trim == 0
      then
      puts "Trimming 0 characters does you no good!"
      print_usage
      exit
      
    #negative trim number
    elsif $op.trim <= 0
      @list_hash.each_key do |key|

          #make sure trim isn't too big
          if (-1 * $op.trim) < key.length
          sub_hash[key] = key.slice(($op.trim * -1)..key.length)

          end
        end        

    #positive trim number
    elsif $op.trim >= 0
      @list_hash.each_key do |key|
    
        #make sure trim isn't too big
        if $op.trim < key.length
          sub_hash[key] = key.slice(0..(key.length - $op.trim - 1))

        end #if
      end #each
    end #if

    @list_hash = sub_hash
  
  end #trim


  def substitute()
    p $op.debug ? "==== substitute() ====\n" : ""

    create_hash()
    
    #error checking for errant options
    # cannot use -all option with sub.
    begin
      $op.all ? a = 1/0 : nil
    rescue
      puts  'Ignoring the all option while performing a PATTERN substitution.'
    ensure
    end

    #error checking for errant options
    # cannot use -invert option with sub.
    begin
      $op.invert ? a = 1/0 : nil
    rescue
      puts  'Script aborted, you cannot apply a PATTERN substitution with the invert option.'
      exit #raise exception to abort program
    ensure
    end

    #populate @list_hash values with gsubbed keys
    sub_hash = Hash.new

    @list_hash.each_key do |key,value|
      if $op.ignore_case == 1
        sub_hash[key] = key.gsub(/#{$pattern}/i,$replacement)
      else
        sub_hash[key] = key.gsub($pattern,$replacement)
      end #if
    end #each.key

    @list_hash.merge!(sub_hash)

  end #substitute


  def rename_action()
    puts $op.debug ? "==== rename_action() ====\n" : ""

    @renamecount = 0

    #get rid of empty values in the hash.
    @list_hash.delete_if { |key, value| value == '' }
    @list_hash.each_pair do |key, value|

      #check for duplicate key/value, & files - prevent clobbering
      if key != value and not @orig_list_array.include?(value)
        @renamecount += 1

        File.rename(key, value)

        #announce renames
        print $op.verbose == 1? "#{key}  >>>   #{value}\n" : ""
        
      else

        #announce clobbering
        print $op.verbose == 1? "#{key} will clobber #{value}; rename aborted.\n" : ""

      end #anti-clobber if
    end #@list_hash.each

  print $op.quiet != 1? "#{@renamecount} of #{@searchcount} files were affected.\n" : ""
  
  end #rename_action
end #filelist


def print_usage()
  puts  'Usage: batch.rename [-acDilqtuvV] [PATTERN] [REPLACEMENT]'
end


def print_version()
  puts "Batch Rename v. #{$version}\n"
end


def print_help()
  
  print_version()
  print_usage()
  puts "--------------------------------"
  puts "Batch.rename is a simple substituation based batch file renamer with several additional options."
  puts ""
  puts "-i --invert        invert results from PATTERN"
  puts "-c --case          ignore case of PATTERN"
  puts "-D --debug         print debug dialogues"
  puts "-u --upperercase"
  puts "-l --lowercase"
  puts "-a --all           disregard PATTERN, include all files"
  puts "-v --version       print program version"
  puts "-V --verbose       verbose output"
  puts "-q --quiet         quiet output"
  puts "-h --help          print this help output"
  puts "-t # --trim #      trim (+#) characters from end or (-#) characters from beginning.  Will match patterns."
  puts ""
  puts "--index            planned, not implimented"
  puts "-X                 planned, only affect extensions"
  puts "-x                 planned, preserve extensions"
  puts "--propercase       planned"
  puts "                   planned, add extension to files lacking them"
  puts "-A --append        planned, append to filename"
  puts "-P --prepend       planned, prepend to filename"
  puts "-s --step          planned, step confirmation of each file rename"
  puts "-c --confirmation  planned, confirm results before proceeding with rename"
  puts "-t --test          planned, dry run of rename, with printed results"
  puts "-r --recursive     planned, recursive rename? - maybe a baaaaad idea"
  puts "-f --force         planned, force overwriting of destination files"
  

end


def main()
#  puts $op.debug ? "==== main() ====\n" : ""
     
  $pattern = ARGV[0]
  $replacement = ARGV[1]
  $replacement ||= ''

  bob = Filelist.new

  if $op.help == 1
    then
    print_help()
    exit
  elsif $op.version == 1
    then
    print_version()
    exit
  end

  unless $op.all == 1
    bob.pattern
  end

 # bob.create_hash

  if $op.upcase == 1
    then
    bob.upcase
  elsif $op.downcase == 1
    then
    bob.downcase
  elsif $op.trim
    then
    bob.trim
  else
    bob.substitute
  end

  bob.rename_action
end #main


#begin
main()
#rescue
#end
