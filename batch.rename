#!/usr/bin/ruby

########################
###   Batch Rename   ###
########################
@version = "1.3.14"

# Based on script by Dmitry Nedospasov
# Updated & expanded by Matt Jordan -

# --- TODO ---

### Error Checking
# check if target filname already exists
  # error on name collisions or continue and report after?
# check permissions
  # abort right away if permissions are lacking
# is file locked?
# error catching

# lock files during name changes?  nesessary?


### Mode Structure
# => Multiple modes? Original PATTERN + GSUB not the heart of the script?
# => Or make the Original PATTERN + GSUB mode heliocentric, with all other
  # functionality requiring options?


### PATTERN stuff
# => Regex support?
# => Wildcard support?


### File Extension Support? (.pdf, .xls, ...)
# => e.g. add specified extensions onto files that do not have extensions
# => change all extensions
# => delete extensions
# => PATTERN + Gsub! only extensions <- not needed with wildcards?

# => x - restrict changes to only extensions
# => X - exclude extensions from changes; preserve extensions


### Confirmation mode
# => report proposed changes and request confirmation of intent
# => require a full yes/no, not y/n

### Options
# => -a  All option - do these things to all files, disregard pattern matching
# => -r --recurse (recursive rename)
  # => default to a confirmation to prevent chaos?
# => -d --directories (rename (only or additionally) directories as well?)
# => -p --print (print changed files after changing) - seperate from confirmation mode
# => -V --verbose (show renames in situ)
# => -v --print program version
# => -t --test (dry run w/ report) - confirmation mode without proceeding
# => --uppercase
# => --lowercase
# => --propercase
# => --sentencecase

# => add to front of all files

# => rename w/ appended numbers
#   => based on date & time?
# => rename based on index?
# => from range?
# => extensions
#   => append
#   => replace extensions
#   => swap
# => trim-first (number of characters forward or backwards)
# => trim-last (number of characters forward or backwards)

# => --date
# => confirm mode?
#
# save often used renames as 'profiles'?
# use regular expressions
# input case sensitivity on/off
# make compatible with windows?
# replace several sets of text at once

#
# => Process???
# => Parse Args
# => Get files -> get list of files
# => Rename Engine
#   => modular
#   => enable features & engine differences with flags?
#   => write seperate cases depending on options?
    # => not very flexible, harder to use seperate options together
#   => seperate cases and modifier options (with flags?)
#
#
#

require 'rubygems'
require 'ftools'

def main(arguments, stdin)

  @dir = `pwd`.chomp + "/"

  oldExt = arguments[0]
  newExt = arguments[1]
  @searchcount = 0
  @renamecount = 0


  if ARGV.length >= 3
    puts 'Too many arguments'
    puts 'Usage: batch.rename PATTERN [REPLACEMENT PATTERN]'
  elsif oldExt == nil
    puts 'Usage: batch.rename PATTERN [REPLACEMENT PATTERN]'
  elsif  @dir == nil
    puts  'Script failed. Could not automagically retrive current working directory.'
  else
    if newExt == nil
      puts "deleting #{oldExt} from file names..."
    else
      puts "renaming #{oldExt} to #{newExt}"
    end
    convertFromTo(@dir,oldExt,newExt)
    print "#{@searchcount} files were searched.\n"
    print "#{@renamecount} files were successfully renamed.\n"
  end
end


def convertFromTo(dir, oldExt, newExt)


  Dir.foreach(dir) do |f|

    #skip file if it is . or .. or directory
    next if f == '.' or f == '..'
    next if File.directory?(f)
    @searchcount += 1

    # fullPath = fullPath.gsub(' ','\ ')

# => if file is a directory recurse into it
#    if File.directory?(fullPath)
#      convertFromTo(fullPath, oldExt, newExt)
#    else

   if newExt == nil
     newName = f.gsub(oldExt,'')
   else
     newName = f.gsub(oldExt,newExt)
   end

    if f != newName
    @renamecount += 1
      
# =>  list file option
#      puts f + '  ->  ' + newName
      File.rename(f,newName)
    end
  end #do
end #def

main(ARGV, STDIN)