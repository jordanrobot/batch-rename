#!/usr/bin/ruby

########################
###   Batch Rename   ###
########################
$version = "1.4.122"

# Based on script by Dmitry Nedospasov
# Updated & expanded by Matt Jordan -


require 'rubygems'
require 'ftools'
require "Getopt/Declare"

args = Getopt::Declare.new(<<'EOF')

-i                  invert [requires: -u || --uppercase || -l || --lowercase] [excludes: -a --all]
{ $invert_pattern = 1 }
--invert            [ditto]

-c                  ignore Pattern Case
{ $ignore_case = 1 }
--case              [ditto]

-u                  upcase [excludes: -l --lowercase]
{ $upcase = 1 }
--uppercase         [ditto]

-l                  lowercase [excludes: -u --uppercase]
{ $downcase = 1}
--lowercase         [ditto]

-a                  all [requires: -u || --uppercase || -l || --lowercase]
{ $apply_to_all = 1}
--all               [ditto]

-v                  Version
{ $print_version = 1 }
--version           [ditto]

-V                  Verbose [excludes: -q --quiet]
{ $verbose = 1 }
--verbose           [ditto]

-q                  Quiet [excludes: -V --verbose]
{ $quiet = 1 }
--quiet           [ditto]


EOF


class Filelist
  def initialize()
    $dir = `pwd`.chomp + "/"
    @orig_list_array = Array.new

    #check for existance of dir - abort if not
    begin
      if $dir == nil
          a = 1/0 #raise exception to abort program
      end
    rescue
      puts  'Script failed. Could not automagically retrive current working directory.'
      a = 1/0 #raise exception to abort program
    ensure
    end

    #create an array of all the filenames - skip directories
    Dir.foreach($dir) do |f|
      next if f == '.' or f == '..'
      next if File.directory?(f)
      @orig_list_array << f
    end #Dir
    @list_array = @orig_list_array

    #Check to see if list_array is empty. - if so abort.
    begin
      if @orig_list_array.empty?
        a = 1/0 #raise exception to abort program
      end
    rescue
      puts "There are no files to rename. Batch is aborting.\n"
      a = 1/0 #raise exception to abort program
    ensure
    end

    @searchcount = @orig_list_array.length

  end #init
    
  def pattern()
    
    # Error check - abort if no pattern!
    begin
      if $pattern == nil
        a = 1/0 #raise exception to abort program
      end
    rescue
      print_usage
      exit #raise exception to abort program
    ensure
    end
    
    positive_array = Array.new
    negative_array = Array.new

    #search for matching patterns - divy the results into two arrays
    # Also deal with the ignore case switch here.
    if $ignore_case == 1
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.downcase.include?($pattern.downcase)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each

    else
      @orig_list_array.each do |a|
        #search for match to pattern
        if a.include?($pattern)
          positive_array << a
        else
          negative_array << a
        end
      end #@list_array.each
    end #if $ignore_case

    #Deal with inversion pattern here:
    if $invert_pattern == 1
      @list_array = negative_array
    else
      @list_array = positive_array
    end

  end #pattern


  def create_hash()
    #create hash from array
    @list_hash = Hash[ *@list_array.collect { |v| [ v, v ] }.flatten ]
  end


  def upcase()
    up_hash = Hash.new
    @list_hash.each_key do |key|
      up_hash[key]=key.to_s.upcase
    end

    #populate @list_hash values with upcased keys
    puts "Changing file names to Uppercase."
    @list_hash.merge!(up_hash)
  end #upcase


  def downcase()
    down_hash = Hash.new
    @list_hash.each_key do |key|
      down_hash[key]=key.to_s.downcase
    end

    #populate @list_hash values with downcased keys
    @list_hash.merge!(down_hash)
    puts "Changing file names to Lowercase."
  end #downcase


  def substitute()

    #error checking for errant options
    # cannot use -all option with sub.
    begin
      if $apply_to_all == 1
        a = 1/0  #raise exception to abort program
      end
    rescue
      puts  'Script aborted, you cannot apply a PATTERN substitution to all files.'
      exit #raise exception to abort program
    ensure
    end

    #error checking for errant options
    # cannot use -invert option with sub.
    begin
      if $invert_pattern == 1
        a = 1/0 #raise exception to abort program
      end
    rescue
      puts  'Script aborted, you cannot apply a PATTERN substitution with the invert option.'
      exit #raise exception to abort program
    ensure
    end

    #populate @list_hash values with gsubbed keys
    sub_hash = Hash.new

    @list_hash.each_key do |key,value|
      if $ignore_case == 1
        sub_hash[key] = key.gsub(/#{$pattern}/i,$replacement)
      else
        sub_hash[key] = key.gsub($pattern,$replacement)
      end #if
    end #each.key

    @list_hash.merge!(sub_hash)

  end #substitute


  def rename_action()
    @renamecount = 0

    #get rid of empty values in the hash.
    @list_hash.delete_if { |key, value| value == '' }
    @list_hash.each_pair do |key, value|

      #check for duplicate key/value, & files - prevent clobbering
      if key != value and not @orig_list_array.include?(value)
        @renamecount += 1

        File.rename(key, value)

        if $verbose == 1
          puts "#{key}  >>>   #{value}"
        end #if verbose

      else

        #announce clobbering
        if $verbose == 1
          puts "#{key} will clobber #{value}; rename aborted."
        end

      end #anti-clobber

    end #@list_hash.each

  unless $quiet == 1
    print "#{@renamecount} of #{@searchcount} files were affected.\n"
  end
  
  end #rename_action

end #filelist

def print_usage()
  puts  'Usage: batch.rename [-acilquvV] [PATTERN] [REPLACEMENT]'
end

def print_version()
  if $print_version == 1
  puts "Batch Rename v. #{$version}"
  exit
  end
end


def main()

  print_version     
  $pattern = ARGV[0]
  $replacement = ARGV[1]
  if $replacement == nil
    $replacement = ''
  end

  bob = Filelist.new

  unless $apply_to_all == 1
    bob.pattern
  end

  bob.create_hash

  if $upcase == 1
    then
    bob.upcase
  elsif $downcase == 1
    then
    bob.downcase
  else
    bob.substitute
  end

  bob.rename_action
end #main


#begin
main()
#rescue
#end
